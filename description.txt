#제목 : 추억의 베네치아 게임

#설명
단어가 화면 위에서 부터 내려온다.
입력란에 텍스트를 입력 후 Enter 를 누른다.
입력 정보와 일치하는 단어가 있는지 확인한다.
-있는 경우
 점수가 올라간다.
 맞춘 갯수가 올라간다.
 단어가 사라진다.
 입력란의 입력 정보가 초기화된다.

-없는 경우
 점수가 떨어진다. (구현 예정)
 틀린 갯수가 올라간다.
 입력란의 입력 정보가 초기화된다.

-공통 처리
 입력란의 입력 정보가 초기화 된다.
 입력 정보가 없을 경우, 아무 처리를 하지 않는다. (입력 정보 초기화만 한다.)
 정확도 계산 (맞춘 갯수, 틀린 갯수 이용)


#구현 원리
미리 단어를 배열에 준비해둔다.
게임이 시작되면 준비한 단어 배열에서 몇 개를 가져와, 새로운 단어 배열에 저장해둔다.
실제로 로직에 이용되는 배열은 새롭게 만든 단어 배열이다.
그 배열을 가지고 반복문을 이용하여, 배열의 길이 만큼 div 를 만든다.
div 에 단어 배열의 값을 넣어줘서 화면에 표시하게 해준다.
만들어진 div 를 화면에 랜덤의 위치에 배치시키기 위해서는,
div 의 부모 html 요소의 position 을 relative 로 해준다.
div 의 position 은 absolute 로 한다.
각 div 가 화면 위에서 아래로 내려오는 에니메이션 효과를 준다.
top 값을 계속더하면 되는데, 그 더하는 처리를 setInterval 을 이용하여
지정한 ms 당 처리되도록 하여 위치를 이동시킨다.


#수정, 구현할 기능
-게임이 종료되는 조건 (수정)
 게임을 하다가 단어가 남았는데 시간이 다 되어 종료된다.

-게임오버 기능 공통화 시키기 (수정, 개선)
 isPlaying 과 다른 몇 개의 종료 변수를 묶어 메서드화 시켜야한다.

-게임이 종료된 후 나타나는 팝업 창에서 버그 (수정)
 (네)를 선택한 경우
 게임을 시작할 때 필요한 변수들의 초기화를 적절히 해줘야한다.

 (아니오)를 선택한 경우
 아니오를 눌러서 초기화면으로 넘어갔다가, 다시 게임 시작 버튼을 누르면 하던 게임 화면이 그대로이다.
 그리고 게임이 멈춘다. 게임을 시작할 때 필요한 변수들의 초기화를 적절히 해줘야한다.

-게임 완료 로직이 존재하지 않음 (수정, 개선)
 게임 시작과 게임 종료의 로직은 있으나, 게임을 클리어했을 때의 로직이 존재하지 않는다.

-Pause 기능 (구현 예정)

-NextLevel 기능 (구현 예정)

-특별한 단어 기능 (구현 예정)
 색갈이 있거나 반짝반짝 거리는 단어에 능력이 존재하도록.
 색갈이 있는 단어는 점수를 다르게 하도록.

-랭킹 기능 (구현 예정)



#이 메서드 어려웠음
function moveDiv() {
  let div = document.querySelectorAll('.dynamic-word-div');
  let pos = 0;

  // 각 디브가 고정 스피드를 갖을 수 있도록 하기 위한 로직.
  // 디브 배열 인덱스와 속도 배열 인덱스를 맞춰서, 속도 값을 랜덤으로 얻음.
  for (let i = 0; i < div.length; i++) {
    speed[i] = Math.floor(Math.random() * 2) + 1;
  }

  let id = setInterval(frame, 100);
  function frame() {
    if (pos == 650) {
      clearInterval(id);
    } else {
      for (let i = 0; i < div.length; i++) {
        pos = div[i].style.top;

        // 포지션 위치를 가속하려 할 때, 포지션 값의 리턴값은 스트링 (px 가 딸려옴). px 를 제거해줘야 했다.
        let temp = pos.replace('px', '');

        // 중요한 변수 - 일단 각 디브가 1px 씩 움직이는 상태에서 다시 움직여야 함.
        // temp++;

        // 첫번째 했던 방법.. 뭔가 이상함
        // let test = Math.floor(Math.random() * 1) + Math.floor(Math.random() * 14);
        // div[i].style.top = temp++ + test + 'px';

        // 두번째 했던 방법(단 frame 위에 let speed 배열 변수 만들어야 함): 하나의 디브가 내려갈 때 속도가 랜덤임
        // 각 디브가 고정 스피드를 가지되, 다른 스피드를 가지도록 하고 싶었다.
        // speed[i] = Math.floor(Math.random() * 5) + 1;
        // div[i].style.top = temp++ + speed[i] + 'px';

        div[i].style.top = temp++ + speed[i] + 'px';
      }
      // let temp1 = div[0].style.top;
      // temp1++;
      // div[0].style.top = temp1 + 'px';
    }
  }
}



